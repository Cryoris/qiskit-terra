import numpy as np
import time
import os
os.environ['QISKIT_IN_PARALLEL'] = 'False'




from scipy.integrate import Radau, ode, solve_ivp, RK45, RK23



from qiskit import Aer

from qiskit.circuit.library import EfficientSU2, RealAmplitudes

from qiskit.opflow.evolutions.varqtes.varqrte import VarQRTE
from qiskit.opflow.evolutions.varqtes.varqite import VarQITE
from qiskit.opflow.evolutions.varqte import ForwardEuler

from qiskit.opflow import StateFn, SummedOp, PauliExpectation
from qiskit.opflow import Z, I, Y, X
np.random.seed = 11

# Evolution time
t = 1

nts = 100
depths = [1]


# Define the expectation value given the Hamiltonian as observable and the state generated by the
#  Ansatz

ode_solvers = [ForwardEuler, RK45]
ode_solvers_names = ['ForwardEuler', 'RK45']

# ode_solvers = [ForwardEuler]
# ode_solvers_names = ['ForwardEuler']

# ode_solvers = [RK45]
# ode_solvers_names = ['RK45']
# regs = [None, 'ridge', 'perturb_diag']
# reg_names = ['lstsq', 'ridge', 'perturb_diag']
regs = [None]
reg_names = ['lstsq']
# regs = ['ridge']
# reg_names = ['ridge']
error_based_odes = [False, True]
error_based_ode_names = ['nat_grad', 'error']

output_dirs = ['illustrative_errorODE_longer']

output_dir = '../'
# output_dir = '/Users/ouf/Box/ChristaPhDFolder/Papers/VarQTE_Error/output'
for dir in output_dirs:
    for l, error_based_ode in enumerate(error_based_odes):
        for k, ode_solver in enumerate(ode_solvers):
            for d in depths:
                for j, reg in enumerate(regs):
                    print(ode_solvers_names[k])
                    print(reg_names[j])
                    # Define the Hamiltonian for the simulation
                    observable = SummedOp([(Z ^ X), (X ^ Z), 3 * (Z ^ Z)]).reduce()
                    # Define Ansatz
                    # ansatz = RealAmplitudes(observable.num_qubits, reps=d)
                    ansatz = EfficientSU2(observable.num_qubits, reps=d)

                    # Define a set of initial parameters
                    parameters = ansatz.ordered_parameters
                    init_param_values = np.zeros(len(ansatz.ordered_parameters))
                    for i in range(ansatz.num_qubits):
                        init_param_values[-(ansatz.num_qubits + i + 1)] = np.pi / 2

                    # Now we stack the observable and the quantum state together.
                    # The evolution time needs to be added as a coefficient to the operator
                    op = ~StateFn(observable) @ StateFn(ansatz)
                    op = t * op

                    print('number time steps', nts)
                    print('depth ', d)
                    print('---------------------------------------------------------------------')

                    t0 = time.time()
                    varqite_snapshot_dir = os.path.join(output_dir, dir, 'imag',
                                                        reg_names[j],
                                                        ode_solvers_names[k] +
                                                        error_based_ode_names[l])

                    varqite = VarQITE(parameters=parameters, grad_method='lin_comb',
                                      init_parameter_values=init_param_values,
                                      num_time_steps=nts,
                                      ode_solver=ode_solver,
                                      backend=Aer.get_backend('statevector_simulator'),
                                      regularization=reg,
                                      error_based_ode=error_based_ode,
                                      snapshot_dir=varqite_snapshot_dir)

                    approx_time_evolved_state_imag = varqite.convert(op)

                    # varqite._operator = op
                    varqite_error_bounds, varqite_reverse_error_bounds = varqite.error_bound(
                        varqite_snapshot_dir, imag_reverse_bound=True)
                    # varqite_error_bounds = varqite.error_bound(
                    #     varqite_snapshot_dir)
                    np.save(os.path.join(varqite_snapshot_dir, 'error_bounds.npy'),
                            varqite_error_bounds)
                    np.save(os.path.join(varqite_snapshot_dir, 'reverse_error_bounds.npy'),
                            varqite_reverse_error_bounds)

                    varqite.plot_results([varqite_snapshot_dir],
                                         [os.path.join(varqite_snapshot_dir,
                                                       'error_bounds.npy')],
                                         [os.path.join(varqite_snapshot_dir,
                                                       'reverse_error_bounds.npy')]
                                          )
                    # varqite.plot_results([varqite_snapshot_dir],
                    #                      [os.path.join(varqite_snapshot_dir,
                    #                                    'error_bounds.npy')])

                    print('run time', (time.time()-t0)/60)

                    
                    # print('---------------------------------------------------------------------')
                    varqrte_snapshot_dir = os.path.join(output_dir, dir, 'real',
                                                        reg_names[j],
                                                        ode_solvers_names[k] +
                                                        error_based_ode_names[l])
                    t0 = time.time()
                    varqrte = VarQRTE(parameters=parameters,
                                    grad_method='lin_comb',
                                    init_parameter_values=init_param_values,
                                    num_time_steps=nts,
                                    ode_solver=ode_solver,
                                    backend=Aer.get_backend('statevector_simulator'),
                                    regularization=reg,
                                    error_based_ode=error_based_ode,
                                    snapshot_dir=varqrte_snapshot_dir
                                    # snapshot_dir=os.path.join('..', 'test')
                                    )
                    # varqrte._operator = 1j* op
                    approx_time_evolved_state_real = varqrte.convert(op)
                    varqrte_error_bounds = varqrte.error_bound(varqrte_snapshot_dir)
                    np.save(os.path.join(varqrte_snapshot_dir, 'error_bounds.npy'),
                            varqrte_error_bounds)
                    #
                    print('run time', (time.time()-t0)/60)
                    varqrte.plot_results([varqrte_snapshot_dir],
                                         [os.path.join(varqrte_snapshot_dir,
                                                       'error_bounds.npy')])


