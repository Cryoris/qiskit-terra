import numpy as np
import os
import time
import os
os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'
os.environ['QISKIT_IN_PARALLEL'] = 'True'
import matplotlib.pyplot as plt


from scipy.integrate import Radau, ode, solve_ivp, RK45, RK23
from qiskit.working_files.varQTE.implicit_euler import BDF, backward_euler_fsolve



from qiskit import Aer

from qiskit.circuit.library import EfficientSU2, RealAmplitudes

from qiskit.opflow.evolutions.varqtes.varqrte import VarQRTE
from qiskit.opflow.evolutions.varqtes.varqite import VarQITE
from qiskit.opflow.evolutions.varqte import ForwardEuler

from qiskit.opflow import StateFn, SummedOp
from qiskit.opflow import Z, I, Y, X
import networkx as nx
from qiskit_optimization.applications import Maxcut
np.random.seed = 131

# Evolution time
t = 10

num_time_steps = [25]
depths = [5]


# Define the expectation value given the Hamiltonian as observable and the state generated by the
#  Ansatz

ode_solvers = [ForwardEuler, RK45]
ode_solvers_names = ['ForwardEuler', 'RK45']

# ode_solvers = [BDF]
# ode_solvers_names = ['BDF']
#
# ode_solvers = [RK45]
# ode_solvers_names = ['RK45']
# regs = ['ridge', 'perturb_diag', None]
# reg_names = ['ridge', 'perturb_diag', 'lstsq']
regs = [None]
reg_names = ['lstsq']
# for nts in num_time_steps:
# nts = num_time_steps[1]
# g = nx.generators.random_graphs.random_regular_graph(4, 6)
# print('graph ', g)


g = nx.Graph()
g.add_nodes_from(range(4))
g.add_edges_from([(0, 1), (1, 2), (0, 2), (1, 4), (4, 3), (2, 3)])
maxcut = Maxcut(g)
# nx.draw(g)
# plt.show()
# print('after draw')
qp = maxcut.to_quadratic_program()
H, offset = qp.to_ising()
observable = H
print('H ising ', observable.to_pauli_op())
for nts in num_time_steps:
    for k, ode_solver in enumerate(ode_solvers):
        for d in depths:
            for j, reg in enumerate(regs):
                print(ode_solvers_names[k])
                print(reg_names[j])
                # Define the Hamiltonian for the simulation
                # Define Ansatz
                ansatz = RealAmplitudes(observable.num_qubits, entanglement='sca', reps=d)
                # ansatz = EfficientSU2(observable.num_qubits, entanglement='sca', reps=d)

                # Define a set of initial parameters
                parameters = ansatz.ordered_parameters
                # init_param_values = np.zeros(len(ansatz.ordered_parameters))
                # for i in range(ansatz.num_qubits):
                #     init_param_values[-(i + 1)] = np.pi / 2
                init_param_values = [5.12065500e-02,  1.22562360e-01, - 6.70631280e-01,
                                  5.08760200e-02,
                 3.25997400e-02,  1.92158400e-02,  1.66097600e-01,  2.72740300e-02,
                 5.63080000e-04, - 7.09539700e-01, - 8.62283620e-01, - 9.91696900e-02,
                 - 1.92514850e-01,  3.08763170e-01 , 3.83842300e-02, - 5.90699800e-02,
                 - 8.43130700e-02,  1.31088520e-01, - 5.94304400e-02,  5.88663700e-02,
                 1.27121720e-01 , 5.75008200e-02, - 2.82536500e-02,  4.93581900e-02,
                 1.14083460e-01 , 1.73757626e+00,  1.66688659e+00,  1.64615613e+00,
                 1.59983932e+00 , 1.64257726e+00]
                #     init_param_values[-(i + 1)] = (np.random.rand(1) + 0.0001) * np.pi / 2
                # init_param_values = (np.random.rand(len(parameters)) + 0.0001) * np.pi / 2
                print(init_param_values)

                # Now we stack the observable and the quantum state together.
                # The evolution time needs to be added as a coefficient to the operator
                op = ~StateFn(observable) @ StateFn(ansatz)
                op = t * op

                print('number time steps', nts)
                print('depth ', d)
                print('---------------------------------------------------------------------')
                t0 = time.time()
                varqite_snapshot_dir = os.path.join('..',
                                                    'output_maxcut_pretrained_from_superposition',
                                                    reg_names[j],
                                                    ode_solvers_names[k] + 'nat_grad')
                # varqite_snapshot_dir = os.path.join('/Users/ouf/Box/ChristaPhDFolder/Papers/VarQTE_Error/output/MaxCut', 'output_maxcut_superposition', 'imag',
                #                                     str(nts)+'_depth_'+str(d),
                #                                     reg_names[j],
                #                                     ode_solvers_names[k] + 'error')
                varqite = VarQITE(parameters=parameters, grad_method='lin_comb',
                                  init_parameter_values=init_param_values,
                                  num_time_steps=nts,
                                  ode_solver=ode_solver,
                                  backend=Aer.get_backend('statevector_simulator'),
                                  regularization=reg,
                                  error_based_ode=False,
                                  snapshot_dir=varqite_snapshot_dir)
                approx_time_evolved_state_imag = varqite.convert(op)
                # varqite._operator = op / op.coeff
                varqite_error_bounds, varqite_reverse_error_bounds = \
                    varqite.error_bound(
                    varqite_snapshot_dir, imag_reverse_bound=True,
                    H=observable.to_matrix(massive=True))
                np.save(os.path.join(varqite_snapshot_dir, 'error_bounds.npy'),
                        varqite_error_bounds)
                np.save(os.path.join(varqite_snapshot_dir, 'reverse_error_bounds.npy'),
                        varqite_reverse_error_bounds)
                # np.save(os.path.join(varqite_snapshot_dir, 'trunc_error_bound.npy'),
                #         trunc_bounds)
                # dir_fast = '../output/imag/10/ridge/RK45error'
                # varqite.print_results([dir_fast], [os.path.join(dir_fast,
                #                                                'error_bounds.npy')])
                varqite.plot_results([varqite_snapshot_dir], [os.path.join(varqite_snapshot_dir,
                                                              'error_bounds.npy')],
                                      [os.path.join(varqite_snapshot_dir,
                                                    'reverse_error_bounds.npy')]
                                      )

                print('run time', (time.time()-t0)/60)
                print('---------------------------------------------------------------------')
                # varqite_snapshot_dir = os.path.join('..', 'output_maxcut_superposition', 'imag',
                #                                     str(nts) + ' depth ' + str(d),
                #                                     reg_names[j],
                #                                     ode_solvers_names[k] + 'error')
                #
                # varqite = VarQITE(parameters=parameters, grad_method='lin_comb',
                #                   init_parameter_values=init_param_values,
                #                   num_time_steps=nts,
                #                   ode_solver=ode_solver,
                #                   backend=Aer.get_backend('statevector_simulator'),
                #                   regularization=reg,
                #                   error_based_ode=True,
                #                   snapshot_dir=varqite_snapshot_dir)
                # approx_time_evolved_state_imag = varqite.convert(op)
                # varqite_error_bounds, varqite_reverse_error_bounds = varqite.error_bound(
                #     varqite_snapshot_dir, imag_reverse_bound=True,
                #     H=observable.to_matrix(massive=True))
                # np.save(os.path.join(varqite_snapshot_dir, 'error_bounds.npy'),
                #         varqite_error_bounds)
                # np.save(os.path.join(varqite_snapshot_dir, 'reverse_error_bounds.npy'),
                #         varqite_reverse_error_bounds)
                # # dir_fast = '../output/imag/10/ridge/RK45error'
                # # varqite.print_results([dir_fast], [os.path.join(dir_fast,
                # #                                                'error_bounds.npy')])
                # varqite.plot_results([varqite_snapshot_dir], [os.path.join(varqite_snapshot_dir,
                #                                                            'error_bounds.npy')],
                #                      [os.path.join(varqite_snapshot_dir,
                #                                    'reverse_error_bounds.npy')]
                #                      )
                #
                # print('run time', (time.time() - t0) / 60)
                print('---------------------------------------------------------------------')

