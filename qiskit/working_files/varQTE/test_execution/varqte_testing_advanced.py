import warnings
from abc import ABC, abstractmethod
from typing import List, Optional, Union, Dict

import numpy as np
import scipy as sp
import os

from qiskit import QuantumCircuit

from qiskit.circuit import ParameterExpression, ParameterVector, Parameter
from qiskit.circuit.library import EfficientSU2, RealAmplitudes

from qiskit.opflow.evolutions.varqtes.varqite import VarQITE
from qiskit.opflow.evolutions.varqtes.varqrte import VarQRTE
from qiskit.opflow.evolutions.matrix_evolution import MatrixEvolution

from qiskit.opflow import StateFn, CircuitStateFn, ListOp, ComposedOp, SummedOp
from qiskit.opflow.operator_globals import  Z, I, Y, X
from qiskit.opflow.gradients import NaturalGradient, CircuitQFI, CircuitGradient, \
    Gradient, QFI
from qiskit.aqua.algorithms.minimum_eigen_solvers.qaoa.var_form import QAOAVarForm

# Evolution time
t = 1
# Instantiate the model ansatz
# entangler_map = [[i+1, i] for i in range(num_qubits - 1)]


# Define the model Hamiltonian
# H = SummedOp([0.3 * Z ^ Z ^ I ^ I, 0.2 * Z ^ I ^ I ^ I, - 0.5 * I ^ Z ^ I ^ I])
H = SummedOp([(Z ^ X), 3. * (Y ^ Y), (Z ^ X), (I ^ Z), (Z ^ I)]).reduce()
# H = t * SummedOp([Y ^ X,  X ^ I])
H = t * H
num_qubits = H.num_qubits

num_time_steps = [10, 20]
depths = [1]
# num_time_steps = [1]
# depths = [1]
entanglements = ['linear']
regularizations = [None, 'perturb_diag', 'ridge']

# Define the expectation value given the Hamiltonian as observable and the state generated by the
#  Ansatz

# varform = QAOAVarForm(observable, p=d)
# params = ParameterVector('x', varform.num_parameters)
# ansatz = StateFn(varform.construct_circuit(params))
# print(ansatz.primitive)
# op = ~StateFn(observable) @ ansatz
# parameters = params[:]
# np.random.seed(2)

for nts in num_time_steps:
    for d in depths:
        for e in entanglements:
            for regularization in regularizations:
                # ansatz = RealAmplitudes(num_qubits, reps=d, entanglement=e)
                # parameters = ansatz.ordered_parameters
                # init_params = np.zeros(len(ansatz.ordered_parameters))
                # for i in range(ansatz.num_qubits):
                #     init_params[-(i + 1)] = np.pi / 2
                ansatz = EfficientSU2(H.num_qubits, reps=d, entanglement=e)
                init_params = np.zeros(len(ansatz.ordered_parameters))
                for i in range(ansatz.num_qubits):
                    init_params[-(ansatz.num_qubits + i + 1)] = np.pi / 2

                # initial_point = np.random.random(len(ansatz.ordered_parameters))
                parameters = ansatz.ordered_parameters
                # op = ~StateFn(observable) @ ansatz
                op = t * ~StateFn(H) @ StateFn(ansatz)

            # ansatz = RealAmplitudes(num_qubits, reps=1)

                print('number time steps', nts)
                print('depth ', d)
                print('entanglement ', e)
                print('---------------------------------------------------------------------')
                if regularization == None:
                    # varqrte = VarQRTE(parameters=parameters, get_error=True, grad_method='lin_comb',
                    #                   init_parameter_values=init_params, num_time_steps=nts,
                    #                   fidelity_to_target=True,
                    #                   snapshot_dir=os.path.join('..', 'output', 'real', e, 'none'),
                    #                   regularization=regularization).convert(op)
                    # ).convert(op)
                    # snapshot_dir=str(nts)+'/'+str(d), regularization='ridge').convert(op)
                    varqite = VarQITE(parameters=parameters, get_error=True, grad_method='lin_comb',
                                      init_parameter_values=init_params, num_time_steps=nts,
                                      fidelity_to_target=True, get_h_terms= True,
                                      snapshot_dir=os.path.join('..', 'output', 'imag', e, 'none',
                                                                'csv_overview'),
                                      regularization=regularization).convert(op)
                else:
                    # varqrte = VarQRTE(parameters=parameters, get_error=True, grad_method='lin_comb',
                    #                  init_parameter_values=init_params, num_time_steps=nts,
                    #                  fidelity_to_target=True,
                    #                   snapshot_dir=os.path.join('..', 'output', 'real', e,
                    #                                             regularization),
                    #                  regularization=regularization).convert(op)
                                     # ).convert(op)
                                     # snapshot_dir=str(nts)+'/'+str(d), regularization='ridge').convert(op)
                    varqite = VarQITE(parameters=parameters, get_error=True, grad_method='lin_comb',
                                     init_parameter_values=init_params, num_time_steps=nts,
                                     fidelity_to_target=True,  get_h_terms= True,
                                     snapshot_dir=os.path.join('..', 'output', 'imag', e,
                                                                regularization, 'csv_overview'),
                                     regularization=regularization).convert(op)
