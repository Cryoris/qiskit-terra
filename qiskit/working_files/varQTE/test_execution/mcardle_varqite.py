import numpy as np
import os

from qiskit import Aer
from qiskit.circuit.library import RealAmplitudes
from qiskit.opflow.evolutions.varqtes.varqite import VarQITE
# from varqte import ForwardEuler
from qiskit.opflow import StateFn, SummedOp
from qiskit.opflow import Z, I, Y, X

from qiskit import QuantumCircuit
from qiskit.circuit import Parameter, ParameterVector
from qiskit.opflow import MatrixOp

np.random.seed = 11

# Evolution time
t = 4

num_time_steps = [4/0.01]
depths = [1]

#######################
H_1 = np.array([
    [1, 0, 0, 0],
    [0, 2, 0, 0],
    [0, 0, 3, 0],
    [0, 0, 0, 0]
])

H1_op = MatrixOp(H_1)

T = ParameterVector('T', 2)
ansatz_mcardle = QuantumCircuit(2)
ansatz_mcardle.rx(T[0], 0)
ansatz_mcardle.cry(T[1], 0, 1)

#######################


# Define the expectation value given the Hamiltonian as observable and the state generated by the
#  Ansatz

for nts in num_time_steps:
    for d in depths:
        # Define the Hamiltonian for the simulation
        # TODO Change here accordingly
        observable = H1_op.to_pauli_op().reduce()
        # Define Ansatz
        # TODO Change here accordingly
        ansatz = ansatz_mcardle

        # Define a set of initial parameters
        #             parameters = tuple(ansatz_mcardle.parameters)
        parameters = list(ansatz.parameters)
        print(f'Initial Parameters: {parameters}')  # Amol: Added print statement

        # TODO Change here accordingly
        init_param_values = np.array([-np.pi / 2, -0.1])
        print(f'Initial Parameter Values: {init_param_values}')  # Amol: Added print statement

        # Now we stack the observable and the quantum state together.
        # The evolution time needs to be added as a coefficient to the operator
        op = ~StateFn(observable) @ StateFn(ansatz)
        op = t * op

        print('number time steps', nts)
        print('depth ', d)
        print('---------------------------------------------------------------------')
        # t0 = time.time()
        varqite_snapshot_dir = os.path.join('.', 'mc_ardle_output')

        varqite = VarQITE(parameters=parameters,
                          grad_method='lin_comb',
                          init_parameter_values=init_param_values,
                          num_time_steps=nts,
                          # ode_solver=ForwardEuler,
                          backend=Aer.get_backend('statevector_simulator'),
                          faster=True,
                          regularization=None,
                          snapshot_dir=varqite_snapshot_dir)
        evolved_state = varqite.convert(op)
        varqite_error_bounds, varqite_reverse_error_bounds = varqite.error_bound(
            varqite_snapshot_dir, imag_reverse_bound=True, H=H_1)
        np.save(os.path.join(varqite_snapshot_dir, 'error_bounds.npy'),
                varqite_error_bounds)
        np.save(os.path.join(varqite_snapshot_dir, 'reverse_error_bounds.npy'),
                varqite_reverse_error_bounds)
        varqite.plot_results([varqite_snapshot_dir], [os.path.join(varqite_snapshot_dir,
                                                      'error_bounds.npy')],
                              [os.path.join(varqite_snapshot_dir,
                                            'reverse_error_bounds.npy')]
                              )
        print(evolved_state)